 Current State Analysis

  ‚úÖ What EXISTS:

  1. Database column: emails.priority_score (integer, defaults to 0)
  2. TypeScript type: EmailRecord.priorityScore
  3. Priority calculation logic: shared/src/projectPriority.ts has sophisticated scoring (computeEmailComponents function)
  4. Database index: emails_triage_priority_idx for fast sorting

  ‚ùå What's MISSING:

  The worker never calculates or stores priority_score when processing emails.

  Looking at worker/src/index.ts:258-273, it upserts:
  {
    id, from_name, from_email, subject,
    received_at, category, is_read, summary, labels
  }

  No priority_score is calculated or stored! All emails default to 0.

  ---
  The Real Problem

  Your priority engine (shared/src/projectPriority.ts) is designed for project-level digest generation, not email triage. It
   calculates priority in the context of:
  - Project tasks
  - Timeline items
  - Email-to-project links
  - Dependencies and conflicts

  But emails come in before they're linked to projects, so you have a chicken-and-egg problem.

  ---
  Recommended Approach: Two-Phase Priority System

  Phase 1: Inbox Triage Priority (Immediate)

  Calculate a standalone email priority when emails first arrive, based on:
  - Category (LEGAL/BOOKING = high, FAN = low)
  - Idle age (older unread = higher)
  - Cross-labels (has date/venue/territory = higher)
  - Triage state (unassigned = high, snoozed = low)

  Phase 2: Contextual Priority (After linking)

  Recalculate using the full Priority Engine when:
  - Email is linked to a project
  - Email affects timeline items
  - Dependencies are created

  ---
  Implementation Plan

  Step 1: Add Simple Email Priority Calculator (Start Here)

  Create shared/src/emailPriority.ts:

  import type { EmailLabel, EmailRecord } from "./types";
  import { getPriorityConfig } from "./priorityConfig";

  export interface EmailPriorityInput {
    category: EmailLabel;
    labels: EmailLabel[];
    receivedAt: string;
    isRead: boolean;
    triageState?: "unassigned" | "acknowledged" | "snoozed" | "resolved";
  }

  export function calculateEmailInboxPriority(
    input: EmailPriorityInput,
    now = new Date()
  ): number {
    const config = getPriorityConfig();
    let score = 0;

    // 1. Category weight (most important)
    const categoryWeight =
      config.email.categoryWeights[input.category] ??
      config.email.defaultCategoryWeight;
    score += categoryWeight;

    // 2. Idle age bonus
    const received = new Date(input.receivedAt);
    const ageHours = (now.getTime() - received.getTime()) / (60 * 60 * 1000);

    if (ageHours < 6) {
      score += Math.round(ageHours * 2); // 0-12 points for first 6h
    } else if (ageHours < 24) {
      score += 12 + Math.round((ageHours - 6) * 1); // 12-30 for 6-24h
    } else {
      score += Math.min(50, 30 + Math.round((ageHours - 24) * 0.5)); // cap at 50
    }

    // 3. Unread bonus
    if (!input.isRead) {
      score += config.email.unreadBonus;
    }

    // 4. Triage state adjustment
    const state = input.triageState ?? "unassigned";
    score += config.email.triageStateAdjustments[state] ?? 0;

    // 5. Cross-label bonuses
    for (const rule of config.email.crossLabelRules) {
      const hasMatch = input.labels.some(label =>
        label.toLowerCase().startsWith(rule.prefix.toLowerCase())
      );
      if (hasMatch) {
        score += rule.weight;
      }
    }

    return Math.max(0, Math.round(score));
  }

  Step 2: Update Worker to Calculate Priority

  Modify worker/src/index.ts:258-273:

  // Add import at top
  import { calculateEmailInboxPriority } from "@kazador/shared";

  // In the upsert block:
  const priorityScore = calculateEmailInboxPriority({
    category,
    labels,
    receivedAt,
    isRead: false,
    triageState: "unassigned"
  });

  const { error: emailError } = await supabase
    .from("emails")
    .upsert({
      id: msg.id,
      from_name: fromName,
      from_email: fromEmail,
      subject,
      received_at: receivedAt,
      category,
      is_read: false,
      summary,
      labels,
      priority_score: priorityScore, // ‚Üê ADD THIS
    }, { onConflict: "id" });

  Step 3: Surface Priority in Dashboard

  Update EmailDashboard.tsx:

  // Add to EmailRecord display
  <div className="flex items-center gap-2">
    <PriorityBadge score={email.priorityScore ?? 0} />
    <span className="text-xs text-gray-500">
      {formatReceivedAt(email.receivedAt)}
    </span>
  </div>

  // Priority badge component
  function PriorityBadge({ score }: { score: number }) {
    if (score >= 80) {
      return (
        <span className="px-2 py-1 rounded-full bg-red-100 text-red-700 text-xs font-bold">
          üî¥ {score}
        </span>
      );
    }
    if (score >= 50) {
      return (
        <span className="px-2 py-1 rounded-full bg-amber-100 text-amber-700 text-xs font-semibold">
          üü° {score}
        </span>
      );
    }
    return (
      <span className="px-2 py-1 rounded-full bg-gray-100 text-gray-600 text-xs">
        {score}
      </span>
    );
  }

  Step 4: Add Default Sorting by Priority

  Update app/lib/supabaseClient.ts (or wherever fetchRecentEmails is):

  const query = supabase
    .from('emails')
    .select('*')
    .order('priority_score', { ascending: false })  // ‚Üê Sort by priority first
    .order('received_at', { ascending: false });    // ‚Üê Then by date

  ---
  Quick Win Actions (Do These First)

  1. Create shared/src/emailPriority.ts with the simple calculator above
  2. Update worker/src/index.ts to call it and store priority_score
  3. Reprocess existing emails with a migration script:
  // Update all existing emails with calculated priority
  const emails = await supabase.from('emails').select('*');
  for (const email of emails) {
    const priority = calculateEmailInboxPriority(email);
    await supabase.from('emails')
      .update({ priority_score: priority })
      .eq('id', email.id);
  }
  4. Display priority badges in EmailDashboard.tsx
  5. Sort inbox by priority by default

  ---
  Why This Solves Your Problem

  Once priorities are stored in the DB, you can:
  - Group emails by priority (High/Medium/Low zones)
  - Filter "needs action" (priority > 50)
  - Show actionable CTAs on high-priority emails only
  - Build playbook triggers based on category + priority thresholds
  - Query efficiently using the existing emails_triage_priority_idx index

  ---
  Next Steps After Priority Works

  Once emails have scores, you can start building the "action center":

  1. Add action buttons for high-priority categories:
    - BOOKING/Offer ‚Üí "Create Lead"
    - PROMO/Promo_Time_Request ‚Üí "Propose Slots"
    - LEGAL/Contract_Draft ‚Üí "Review Contract"
  2. Create playbook suggestion system:
  function getPlaybookSuggestion(email: EmailRecord) {
    if (email.category === "BOOKING/Offer" && email.priorityScore >= 60) {
      return {
        playbook: "Booking Enquiry",
        actions: ["Extract venue/fee", "Score brand fit", "Draft reply"]
      };
    }
    // ...
  }
  3. Build quick-action modals that execute playbook steps

  